<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fluid Simulation — HTML + Canvas</title>
  <style>
    :root{--bg:#0b1220;--panel:#0f1724;--accent:#1f2937;--text:#e6eef8}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial}
    body{background:linear-gradient(180deg,#05060b, #071126);color:var(--text);display:flex;align-items:center;justify-content:center;padding:18px}
    .app{width:100%;max-width:1100px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;overflow:hidden;box-shadow:0 10px 30px rgba(2,6,23,0.6)}
    .toolbar{display:flex;gap:8px;padding:12px;background:var(--panel);align-items:center}
    .toolbar .spacer{flex:1}
    button{background:var(--accent);color:var(--text);border:0;padding:8px 12px;border-radius:10px;cursor:pointer}
    .controls{display:flex;gap:12px;align-items:center;padding:12px;background:rgba(255,255,255,0.02);}
    label{font-size:13px;color:#cfe3ff}
    input[type=range]{width:180px}
    .canvas-wrap{background:var(--bg);display:block}
    canvas{display:block;width:100%;height:600px}
    .hud{position:absolute;left:14px;top:14px;color:rgba(255,255,255,0.85);font-size:13px}
  </style>
</head>
<body>
  <div class="app">
    <div class="toolbar">
      <button id="runBtn">Pause</button>
      <button id="resetBtn">Reset</button>
      <button id="bigSplat">Big Splat</button>
      <button id="downSplat">Down Splat</button>
      <div class="spacer"></div>
      <div style="color:#9fb8ff;font-size:13px">Tip: drag on canvas to add splats</div>
    </div><div class="controls">
  <label>Particles <input id="countRange" type="range" min="200" max="8000" value="2000" /></label>
  <label>Viscosity <input id="viscRange" type="range" min="0" max="0.2" step="0.001" value="0.02" /></label>
  <label>Stiffness <input id="stiffRange" type="range" min="0" max="2" step="0.01" value="0.5" /></label>
</div>

<div style="position:relative" class="canvas-wrap">
  <div class="hud" id="hud">Particles: 0</div>
  <canvas id="c"></canvas>
</div>

  </div><script>
(function(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');
  const runBtn = document.getElementById('runBtn');
  const resetBtn = document.getElementById('resetBtn');
  const bigSplatBtn = document.getElementById('bigSplat');
  const downSplatBtn = document.getElementById('downSplat');

  const countRange = document.getElementById('countRange');
  const viscRange = document.getElementById('viscRange');
  const stiffRange = document.getElementById('stiffRange');

  let params = {
    w: 800,
    h: 600,
    particleRadius: 2.0,
    restDensity: 10,
    smoothingRadius: 16,
    dt: 1/60
  };

  let particleCount = parseInt(countRange.value, 10);
  let viscosity = parseFloat(viscRange.value);
  let stiffness = parseFloat(stiffRange.value);

  let running = true;
  let particles = [];
  let grid = [];
  let cols = 0, rows = 0;

  function resize(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(300, Math.floor(rect.width));
    canvas.height = 600; // fixed height for consistency
    params.w = canvas.width; params.h = canvas.height;
    initGrid();
  }

  window.addEventListener('resize', resize);
  // ensure canvas stretches to container width on load
  setTimeout(resize, 20);

  function initGrid(){
    const r = params.smoothingRadius;
    cols = Math.ceil(params.w / r);
    rows = Math.ceil(params.h / r);
    grid = new Array(cols * rows);
    for(let i=0;i<grid.length;i++) grid[i]=[];
  }

  function gridIndex(x,y){
    const c = Math.floor(x/params.smoothingRadius);
    const r = Math.floor(y/params.smoothingRadius);
    if(c<0||r<0||c>=cols||r>=rows) return -1;
    return r*cols + c;
  }

  function clearGrid(){ for(let i=0;i<grid.length;i++) grid[i].length=0; }

  function initParticles(count){
    particles = [];
    for(let i=0;i<count;i++){
      const x = Math.random()*params.w*0.9 + params.w*0.05;
      const y = Math.random()*params.h*0.9 + params.h*0.05;
      particles.push({x,y,vx:0,vy:0,ax:0,ay:0,density:0,pressure:0});
    }
    initGrid();
  }

  function splatAt(x,y,vx,vy,radius=30){
    const r2 = radius*radius;
    for(let i=0;i<particles.length;i++){
      const dx = particles[i].x - x; const dy = particles[i].y - y;
      const d2 = dx*dx + dy*dy;
      if(d2>r2) continue;
      const f = 1 - Math.sqrt(d2)/radius;
      particles[i].vx += vx * f;
      particles[i].vy += vy * f;
    }
    for(let k=0;k<8;k++){
      if(Math.random()<0.6) continue;
      const nx = x + (Math.random()-0.5)*radius*0.5;
      const ny = y + (Math.random()-0.5)*radius*0.5;
      particles.push({x:nx,y:ny,vx: vx*0.2, vy: vy*0.2, ax:0, ay:0, density:0, pressure:0});
    }
  }

  function step(dt){
    const h = params.smoothingRadius; const h2 = h*h; const mass = 1.0; const restDensity = params.restDensity;
    // rebuild grid
    initGrid(); clearGrid();
    for(let i=0;i<particles.length;i++){
      const idx = gridIndex(particles[i].x, particles[i].y);
      if(idx>=0) grid[idx].push(i);
    }

    // density & pressure
    for(let i=0;i<particles.length;i++){
      const pi = particles[i]; let density = 0;
      const gx = Math.floor(pi.x/h); const gy = Math.floor(pi.y/h);
      for(let ox=-1; ox<=1; ox++) for(let oy=-1; oy<=1; oy++){
        const cx = gx+ox; const cy = gy+oy; if(cx<0||cy<0||cx>=cols||cy>=rows) continue;
        const bucket = grid[cy*cols + cx];
        for(let j=0;j<bucket.length;j++){
          const pj = particles[bucket[j]]; const dx = pi.x - pj.x; const dy = pi.y - pj.y; const r2 = dx*dx + dy*dy;
          if(r2 < h2){ const t = (h2 - r2)/h2; density += mass * t*t*t; }
        }
      }
      pi.density = density; pi.pressure = Math.max(0, stiffness * (density - restDensity));
    }

    // forces
    for(let i=0;i<particles.length;i++){
      const pi = particles[i]; let ax = 0, ay = 0;
      const gx = Math.floor(pi.x/h); const gy = Math.floor(pi.y/h);
      for(let ox=-1; ox<=1; ox++) for(let oy=-1; oy<=1; oy++){
        const cx = gx+ox; const cy = gy+oy; if(cx<0||cy<0||cx>=cols||cy>=rows) continue;
        const bucket = grid[cy*cols + cx];
        for(let b=0;b<bucket.length;b++){
          const j = bucket[b]; if(j===i) continue;
          const pj = particles[j]; const dx = pi.x - pj.x; const dy = pi.y - pj.y; const r2 = dx*dx + dy*dy;
          if(r2 < h2 && r2 > 1e-6){ const r = Math.sqrt(r2); const t = (h - r)/h; const pressureTerm = -0.5*(pi.pressure + pj.pressure)*t/(r);
            ax += pressureTerm * dx; ay += pressureTerm * dy;
            const dvx = pj.vx - pi.vx; const dvy = pj.vy - pi.vy; ax += viscosity * dvx * t; ay += viscosity * dvy * t; }
        }
      }
      ay += 30 * 0.5; // gravity
      pi.ax = ax / (pi.density + 1e-6); pi.ay = ay / (pi.density + 1e-6);
    }

    // integrate
    for(let i=0;i<particles.length;i++){
      const p = particles[i]; p.vx += p.ax * dt; p.vy += p.ay * dt;
      p.vx *= 0.999; p.vy *= 0.999;
      p.x += p.vx * dt * 60; p.y += p.vy * dt * 60;
      const r = params.particleRadius;
      if(p.x < r){ p.x = r + Math.random()*0.5; p.vx *= -0.5; }
      if(p.x > params.w - r){ p.x = params.w - r - Math.random()*0.5; p.vx *= -0.5; }
      if(p.y < r){ p.y = r + Math.random()*0.5; p.vy *= -0.5; }
      if(p.y > params.h - r){ p.y = params.h - r - Math.random()*0.5; p.vy *= -0.5; }
    }

    // trim
    if(particles.length > Math.max(100, particleCount * 3)) particles.splice(particleCount, particles.length - particleCount);
  }

  function render(){
    const w = params.w, h = params.h;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,w,h);
    ctx.save(); ctx.globalCompositeOperation = 'lighter';
    for(let i=0;i<particles.length;i++){
      const pi = particles[i]; const speed = Math.sqrt(pi.vx*pi.vx + pi.vy*pi.vy); const t = Math.min(1, speed/150);
      const r = Math.floor(180 + t*75); const g = Math.floor(200 - t*120); const b = Math.floor(255 - t*200);
      ctx.fillStyle = `rgba(${r},${g},${b},0.9)`; ctx.beginPath(); ctx.arc(pi.x, pi.y, params.particleRadius, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
    hud.textContent = `Particles: ${particles.length}  —  Viscosity: ${viscosity.toFixed(3)}  Stiffness: ${stiffness.toFixed(2)}`;
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;
    if(running) step(dt);
    render();
    requestAnimationFrame(loop);
  }

  // pointer interactions
  let isDown = false; let lastPos = null;
  function getPos(e){ const r = canvas.getBoundingClientRect(); if(e.touches && e.touches[0]) return {x: e.touches[0].clientX - r.left, y: e.touches[0].clientY - r.top}; return {x: e.clientX - r.left, y: e.clientY - r.top}; }
  function onDown(e){ isDown=true; lastPos = getPos(e); splatAt(lastPos.x, lastPos.y, 0,0,20); }
  function onMove(e){ if(!isDown) return; const p = getPos(e); const vx = (p.x - lastPos.x) * 5; const vy = (p.y - lastPos.y) * 5; splatAt(p.x, p.y, vx * 1.5, vy * 1.5, 40); lastPos = p; }
  function onUp(){ isDown=false; lastPos=null; }

  canvas.addEventListener('pointerdown', onDown); canvas.addEventListener('pointermove', onMove); window.addEventListener('pointerup', onUp);
  canvas.addEventListener('touchstart', onDown, {passive:true}); canvas.addEventListener('touchmove', onMove, {passive:true}); window.addEventListener('touchend', onUp);

  // controls
  runBtn.addEventListener('click', ()=>{ running = !running; runBtn.textContent = running ? 'Pause' : 'Run'; });
  resetBtn.addEventListener('click', ()=> initParticles(particleCount));
  bigSplatBtn.addEventListener('click', ()=> splatAt(params.w/2, params.h/2, (Math.random()-0.5)*400, -500, 120));
  downSplatBtn.addEventListener('click', ()=> splatAt(params.w/2, params.h/2, 0, 400, 120));

  countRange.addEventListener('input', (e)=>{ particleCount = parseInt(e.target.value,10); const target = particleCount; if(particles.length < target) initParticles(target); else particles.length = Math.min(particles.length, target); });
  viscRange.addEventListener('input', (e)=>{ viscosity = parseFloat(e.target.value); });
  stiffRange.addEventListener('input', (e)=>{ stiffness = parseFloat(e.target.value); });

  // start
  initParticles(particleCount);
  requestAnimationFrame(loop);
})();
</script></body>
</html>
